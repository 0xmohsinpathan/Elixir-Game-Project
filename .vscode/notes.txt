@type color :: :green | :yellow | :grey

@words [
    "tests",
    "heros",
    "hello",
    "error"
  ]

  @spec play(String.t(), integer()) :: :ok
  def play(answer \\ Enum.random(@words), attempt \\ 0)
  def play(answer, 6), do: IO.puts("Wrong! The answer was #{answer}")

  def play(answer, attempt) do
    guess = IO.gets("Enter a five letter word: ") |> String.trim()

    if guess == answer do
      IO.puts("You win!")
    else
      feedback_list = feedback(answer, guess)
      IO.puts(color_feedback(guess, feedback_list))
      play(answer, attempt + 1)
    end
  end

  @doc """

  Uses IO.ANSI to create colored feedback for a guess.

  ## Examples
      iex> Games.Wordle.color_feedback("toast", [:green, :yellow, :grey, :yellow, :yellow])
      "\e[32mt\e[33mo\e[90ma\e[33ms\e[33mt\e[39m"
  """
  @spec color_feedback(String.t(), [color()]) :: String.t()
  def color_feedback(guess, feedback_list) do
    guess_list = String.split(guess, "", trim: true)

    message =
      Enum.zip([guess_list, feedback_list])
      |> Enum.map_join(fn
        {char, :green} -> IO.ANSI.green() <> char
        {char, :grey} -> IO.ANSI.light_black() <> char
        {char, :yellow} -> IO.ANSI.yellow() <> char
      end)

    message <> IO.ANSI.default_color()
  end

  @doc """

  Return a list of feedback colors based on an answer and a guess.

  ## Examples
      iex> Games.Wordle.feedback("toast", "tarts")
      [:green, :yellow, :grey, :yellow, :yellow]
  """
  @spec feedback(String.t(), String.t()) :: [color()]
  def feedback(answer, guess) do
    answer_list = String.split(answer, "", trim: true)
    guess_list = String.split(guess, "", trim: true)

    {guess_list, answer_list}
    |> replace_greens()
    |> replace_yellows()
    |> replace_greys()
    |> elem(0)
  end

  @spec replace_greens(tuple()) :: tuple()
  def replace_greens({guess_list, answer_list}) do
    Enum.zip(guess_list, answer_list)
    |> Enum.map(fn
      {same, same} -> {:green, nil}
      pair -> pair
    end)
    |> Enum.unzip()  end

  @spec replace_yellows(tuple()) :: tuple()
  def replace_yellows({guess_list, answer_list}) do
    # relies upon all greens being replaced already
    Enum.reduce(guess_list, {[], answer_list}, fn guess_char, {result, remaining} ->
      answer_index = Enum.find_index(remaining, fn answer_char -> guess_char == answer_char end)

      if answer_index do
        {result ++ [:yellow], List.replace_at(remaining, answer_index, nil)}
      else
        {result ++ [guess_char], remaining}
      end
    end)
  end

  @spec replace_greys(tuple()) :: tuple()
  def replace_greys({guess_list, answer_list}) do
    # assumes all remaining characters are grey
    Enum.zip(guess_list, answer_list)
    |> Enum.map(fn
      {:green, _} -> {:green, nil}
      {:yellow, _} -> {:yellow, nil}
      _ -> {:grey, nil}
    end)
    |> Enum.unzip()
  end
end
****************
def initial_state(secret_letters) do
 secret_letters
 |> Enum.map(fn letter -> {:incorrect, letter} end)
 end


 def guess(player_guess, secret_word) do
 player_guess
 |> correct_pass(secret_word)
 |> partial_pass(player_guess)
 end

 def correct_pass(player_guess, secret_letters) do
 secret_letter_charlist = String.to_charlist(secret_letters)

 {result, remainders} =
 player_guess
 |> String.to_charlist()
 |> Enum.zip(initial_state(secret_letter_charlist))
 |> Enum.reduce({[], secret_letter_charlist}, fn {guess_letter, {_status, secret_letter}}, {result, remaining_letters} -> compare_letter(guess_letter, secret_letter, result, remaining_letters) 
 end)

 {Enum.reverse(result), remainders}
 end

def compare_letter(letter, letter, result, remaining_letters) do
{[{:correct, to_string([letter])} | result], remaining_letters -- [letter]}
end

def compare_letter(letter, letter, result, remaining_letters) do
{[{:incorrect, to_string([letter])} | result], remaining_letters}
end

def partial_pass({letter_state, remainders}, player_guess) do
{result, remainders} = 
player_guess
|> String.to_charlist()
|> Enum.zip(letter_state)
|> Enum.reduce({[], remainders}, fn {guess_letter, {status, secret_letter}}, {result, remaining_letter} -> partial_match(guess_letter, status, remaining_letters, result) end)
{Enum.reverse(result), remainders}
end

defp partial_match(guess_letter, :correct, remainders, result) do
{[{:correct, to_string([guess_letter])} | result], remainders}
end

defp (guess_letter, _, remainders, result) do
cond do
Enum.member?(remainders, guess_letter) -> {[{:partial, to_string([guess_letter])} | result], remainders -- [guess_letter]}

true -> {[{:incorrect, to_string([guess_letter])} | result], remainders}
end
end

